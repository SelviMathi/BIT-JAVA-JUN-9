          java.util.Collection (Interface)
                     |
    ----------------------------------------
    |                                      |
 List (Interface)                      Set (Interface)
    |                                      |
    |                                      |
 -----------                        -----------------
 |    |    |                        |       |       |
ArrayList LinkedList Vector     HashSet LinkedHashSet TreeSet

Queue (Interface)
    |
 PriorityQueue, ArrayDeque

-------------------------------------------

       java.util.Map (Interface)
                    |
          -----------------------
          |                     |
        HashMap          TreeMap / LinkedHashMap



Collection Interface
The root interface in the collection hierarchy for List, Set, and Queue.


2. List Interface (Ordered, Allows Duplicates)
Class	            Features
ArrayList	        Fast random access, resizable array
LinkedList	        Doubly-linked list, fast insert/delete
Vector	            Thread-safe (synchronized), legacy
Stack	            LIFO stack (extends Vector)

3. Set Interface (No Duplicates)
Class	            Features
HashSet	            No duplicates, no order
LinkedHashSet	    Maintains insertion order
TreeSet	            Sorted, no duplicates (uses Red-Black Tree)

4. Queue Interface (FIFO)
Class	            Features
PriorityQueue	    Elements sorted by natural/comparator order
ArrayDeque	        Double-ended queue, no capacity limit

5. Map Interface (Key-Value Pairs)
Class	            Features
HashMap	            Fast, no order
LinkedHashMap      	Maintains insertion order
TreeMap	            Sorted by keys
Hashtable	        Legacy, thread-safe

*************************************************************************
List is an interface in java.util.

It allows ordered collection of duplicate elements.

You can access elements by index.

System.out.println("\n--- ArrayList ---");
        ArrayList<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add(1, "Grape");        // Insert at index
        arrayList.set(2, "Orange");       // Replace
        arrayList.remove("Banana");       // Remove by value
        arrayList.remove(0);              // Remove by index
        arrayList.add("Mango");
        System.out.println("ArrayList: " + arrayList);
        System.out.println("Contains Mango? " + arrayList.contains("Mango"));
        System.out.println("Index of Mango: " + arrayList.indexOf("Mango"));
        System.out.println("Size: " + arrayList.size());
        arrayList.clear();                // Remove all
    System.out.println("After clear(): " + arrayList);

*******************************************************************************

System.out.println("\n--- LinkedList ---");
        LinkedList<Integer> ll = new LinkedList<>();
        ll.add(10); ll.addFirst(5); ll.addLast(20);
        System.out.println("LinkedList: " + ll);
        ll.removeFirst(); ll.removeLast();
        System.out.println("After removing ends: " + ll);
        ll.add(15); ll.add(25); ll.add(2, 18);
        System.out.println("LinkedList after add: " + ll);
        System.out.println("First: " + ll.getFirst() + ", Last: " + ll.getLast());

*******************************************************************************
System.out.println("\n--- Vector ---");
        Vector<String> vector = new Vector<>();
        vector.add("A"); vector.add("B");
        vector.addElement("C");              // Legacy method
        vector.remove(1);
        System.out.println("Vector: " + vector);
        System.out.println("Element at 0: " + vector.elementAt(0)); // legacy method
        vector.set(0, "Z");
        System.out.println("Modified Vector: " + vector);
        System.out.println("Capacity: " + vector.capacity());

*******************************************************************************
System.out.println("\n--- Stack ---");
        Stack<Integer> stack = new Stack<>();
        stack.push(100); stack.push(200);
        System.out.println("Top: " + stack.peek());
        stack.pop();
        System.out.println("After pop: " + stack);
        System.out.println("Is Empty? " + stack.isEmpty());
        System.out.println("Search(100): " + stack.search(100)); // 1-based index


*******************************************************************************
Common methods

list.addAll
list.retainAll
list.removeAll
Collections.reverse
Collections.sort
Collections.rotate(list,-2);
Collections.rotate(list,3);
Collections.reverse(list);
Collections.swap(list, 0, 2);
Collections.shuffle(list);
Collections.fill(list, "X");
int freq = Collections.frequency(list, "A");
Collections.max(list);
Collections.min(list);
List<String> original = new ArrayList<>(Arrays.asList("One", "Two"));
List<String> unmodifiable = Collections.unmodifiableList(original);

*******************************************************************************
LIST--->ARRAY
List<String> list = Arrays.asList("x", "y", "z");
        String[] arr = list.toArray(new String[0]);
        System.out.println(Arrays.toString(arr)); 

 List<String> list = new ArrayList<>();
        list.add("x");
        list.add("y");
        list.add("z");
        String[] arr = list.toArray(new String[0]);
        System.out.println(Arrays.toString(arr));

ARRAY-->LIST

int[] arr = {1, 2, 3};
List<Integer> list = new ArrayList<>();
for (int num : arr) list.add(num);
***************************************************************
List<String> list = List.of("Apple", "Banana", "Cherry");//IMMUTABLE


Prefer ArrayList for frequent reads and random access.

Use LinkedList for frequent insertions/removals at ends.

Avoid Vector unless thread-safety is needed (old, synchronized).

Stack is LIFO, internally uses Vector

************Programs*************
Array Operation	        Manual Implementation	            Built-in Method
Append	                arr[size++] = value;	          ArrayList.add(value);
Insert	                Shift elements, then insert	    ArrayList.add(index, value);
Delete	                Shift elements left	            ArrayList.remove(index);
Get	                    arr[index]	                    ArrayList.get(index);
Update                    arr[index] = value;	            ArrayList.set(index, value);
Search	                Loop through array	            ArrayList.indexOf(value);
Shift Left	            Loop and shift	                System.arraycopy()
Shift Right            	Loop and shift	                Collections.rotate(arr, -1);
Rotate Left	            Loop and swap	                  Collections.rotate(arr, -1);
Rotate Right	          Loop and swap                  	Collections.rotate(arr, 1);

**********************************************************************************************
Set is a part of Java Collections Framework.

It does not allow duplicate elements.

Elements are unordered (unless you use specific types like LinkedHashSet or TreeSet).

Belongs to java.util package.


Set<Integer> set1 = new HashSet<>();
Set<String> set2 = new LinkedHashSet<>();
Set<Double> set3 = new TreeSet<>();


Set<Integer> a = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> b = new HashSet<>(Arrays.asList(3, 4, 5));

// Union
Set<Integer> union = new HashSet<>(a);
union.addAll(b);  // [1, 2, 3, 4, 5]

// Intersection
Set<Integer> intersection = new HashSet<>(a);
intersection.retainAll(b);  // [3]

// Difference
Set<Integer> diff = new HashSet<>(a);
diff.removeAll(b);  // [1, 2]


| Method               | Description                               |
| -------------------- | ----------------------------------------- |
| `add(E e)`           | Adds an element if not already present    |
| `addAll(Collection)` | Adds all elements from another collection |
| `remove(Object o)`   | Removes the element                       |
| `contains(Object o)` | Checks if element exists                  |
| `isEmpty()`          | Checks if set is empty                    |
| `size()`             | Returns number of elements                |
| `clear()`            | Removes all elements                      |
| `iterator()`         | Returns an iterator                       |

*************************************************************
Iterator is an interface in java.util.

It is used to traverse a collection (like List, Set, etc.).

Works with all classes that implement Collection (like ArrayList, LinkedList, etc.**********************************************************************************************

| Method      | Description                                   |
| ----------- | --------------------------------------------- |
| `hasNext()` | Checks if there is another element            |
| `next()`    | Returns the next element                      |
| `remove()`  | Removes the last element returned by `next()` |

List<Integer> list = new ArrayList<>(Arrays.asList(10, 20, 30));

Iterator<Integer> itr = list.iterator();

while (itr.hasNext()) {
    if (itr.next() == 30) {
        itr.remove(); // safe removal during iteration
    }
}
OR
for (Integer item : list) {
    System.out.println(item);
}
*************************************************************

QUEUE

A Queue is a linear data structure that follows FIFO: First In, First Out.

Available in java.util under the Queue<E> interface.

| Method      | Description                                 |
| ----------- | ------------------------------------------- |
| `add(e)`    | Inserts element, throws error if full       |
| `offer(e)`  | Inserts element, returns false if full      |
| `poll()`    | Removes and returns head, or `null`         |
| `remove()`  | Removes and returns head, or error          |
| `peek()`    | Returns head without removing (or `null`)   |
| `element()` | Same as `peek()`, but throws error if empty |


*******************************************************************************
Example Using Queue (with LinkedList)

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        queue.offer("A");
        queue.offer("B");
        queue.offer("C");

        System.out.println("Head: " + queue.peek());  // A

        System.out.println("Removed: " + queue.poll()); // A
        System.out.println("Queue: " + queue);          // [B, C]
    }
}


*******************************************************************************
Example Using PriorityQueue (Min-Heap by default)

import java.util.*;

public class Main {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        pq.offer(50);
        pq.offer(10);
        pq.offer(30);

        while (!pq.isEmpty()) {
            System.out.println(pq.poll());  // 10, 30, 50
        }
    }
}

*******************************************************************************
Example Using ArrayDeque

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Deque<String> dq = new ArrayDeque<>();

        dq.offer("Java");
        dq.offerFirst("C++");  // Insert at front
        dq.offerLast("Python");

        System.out.println(dq);           // [C++, Java, Python]
        System.out.println(dq.pollLast()); // Python
    }
}


*************************************************************

MAP

A Map is a key-value pair collection.

Each key must be unique, but values can be duplicated.

Belongs to the java.util package.


| Method                    | Description                                  |
| ------------------------- | -------------------------------------------- |
| `put(K key, V value)`     | Adds a key-value pair                        |
| `get(K key)`              | Retrieves value by key                       |
| `remove(K key)`           | Removes entry by key                         |
| `containsKey(K key)`      | Checks if key exists                         |
| `containsValue(V value)`  | Checks if value exists                       |
| `putIfAbsent(K, V)`       | Adds if key is not already present           |
| `replace(K key, V value)` | Updates value if key exists                  |
| `isEmpty()`               | Checks if map is empty                       |
| `size()`                  | Returns number of entries                    |
| `clear()`                 | Removes all entries                          |

getOrDefault(K key, V defaultVal)  |Returns value if key exists, else returns default.
map.getOrDefault(2, "Unknown"); // "Unknown"


keySet()`                          | Returns a Set of all keys                    |
Set<Integer> keys = map.keySet();

values()`                          | Returns a Collection of all values           
Collection<String> vals = map.values();

`entrySet()`                       | Returns Set of key-value pairs (`Map.Entry`) |
 `
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println("Key: " + entry.getKey());
    System.out.println("Value: " + entry.getValue());
}

Iterator<Map.Entry<Integer, String>> itr = map.entrySet().iterator();
while (itr.hasNext()) {
    Map.Entry<Integer, String> entry = itr.next();
    System.out.println(entry.getKey() + " : " + entry.getValue());
}

compute(K key, BiFunction)          Modifies value based on key and current value.
map.compute(1, (k, v) -> v + " Pie"); // Apple → Apple Pie


*************************************************************


1.Segregating positive and negative numbers

Using Arraylist
import java.util.*;

public class Main {
    public static void segregateArray(int[] arr) {
        List<Integer> positive = new ArrayList<>();
        List<Integer> negative = new ArrayList<>();

        for (int num : arr) {
            if (num >= 0)
                positive.add(num);
            else
                negative.add(num);
        }

        // Merge both lists back to array
        int i = 0;
        for (int num : negative) arr[i++] = num;
        for (int num : positive) arr[i++] = num;
    }

    public static void main(String[] args) {
        int[] arr = {12, -7, 5, -3, 9, -6, 8, -2};
        segregateArray(arr);
       System.out.println("Segregated Array: " + Arrays.toString(arr));
    
    }
}


Using pointers
import java.util.Arrays;

public class SegregateNumbers {
    public static void segregate(int[] arr) {
        int left = 0, right = arr.length - 1;

        while (left < right) {
            // Move left if it is negative
            if (arr[left] < 0) {
                left++;
            }
            // Move right if it is positive
            else if (arr[right] > 0) {
                right--;
            }
            // Swap when left is positive and right is negative
            else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {10, -1, 20, 4, -6, -9, 8, -3};
        System.out.println("Before segregation: " + Arrays.toString(arr));
        segregate(arr);
        System.out.println("After segregation: " + Arrays.toString(arr));
    }
}

2.Inserting in a sorted Array and checking if an Array is sorted

3.Merging two sorted arrays

4.Finding duplicate elements in a Integer array

5.Finding missing elements in Arrays - Different Methods

