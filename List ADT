          java.util.Collection (Interface)
                     |
    ----------------------------------------
    |                                      |
 List (Interface)                      Set (Interface)
    |                                      |
    |                                      |
 -----------                        -----------------
 |    |    |                        |       |       |
ArrayList LinkedList Vector     HashSet LinkedHashSet TreeSet

Queue (Interface)
    |
 PriorityQueue, ArrayDeque

-------------------------------------------

       java.util.Map (Interface)
                    |
          -----------------------
          |                     |
        HashMap          TreeMap / LinkedHashMap



Collection Interface
The root interface in the collection hierarchy for List, Set, and Queue.


2. List Interface (Ordered, Allows Duplicates)
Class	            Features
ArrayList	        Fast random access, resizable array
LinkedList	        Doubly-linked list, fast insert/delete
Vector	            Thread-safe (synchronized), legacy
Stack	            LIFO stack (extends Vector)

3. Set Interface (No Duplicates)
Class	            Features
HashSet	            No duplicates, no order
LinkedHashSet	    Maintains insertion order
TreeSet	            Sorted, no duplicates (uses Red-Black Tree)

4. Queue Interface (FIFO)
Class	            Features
PriorityQueue	    Elements sorted by natural/comparator order
ArrayDeque	        Double-ended queue, no capacity limit

5. Map Interface (Key-Value Pairs)
Class	            Features
HashMap	            Fast, no order
LinkedHashMap      	Maintains insertion order
TreeMap	            Sorted by keys
Hashtable	        Legacy, thread-safe

*************************************************************************
List is an interface in java.util.

It allows ordered collection of duplicate elements.

You can access elements by index.

System.out.println("\n--- ArrayList ---");
        ArrayList<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add(1, "Grape");        // Insert at index
        arrayList.set(2, "Orange");       // Replace
        arrayList.remove("Banana");       // Remove by value
        arrayList.remove(0);              // Remove by index
        arrayList.add("Mango");
        System.out.println("ArrayList: " + arrayList);
        System.out.println("Contains Mango? " + arrayList.contains("Mango"));
        System.out.println("Index of Mango: " + arrayList.indexOf("Mango"));
        System.out.println("Size: " + arrayList.size());
        arrayList.clear();                // Remove all
    System.out.println("After clear(): " + arrayList);

*******************************************************************************

System.out.println("\n--- LinkedList ---");
        LinkedList<Integer> ll = new LinkedList<>();
        ll.add(10); ll.addFirst(5); ll.addLast(20);
        System.out.println("LinkedList: " + ll);
        ll.removeFirst(); ll.removeLast();
        System.out.println("After removing ends: " + ll);
        ll.add(15); ll.add(25); ll.add(2, 18);
        System.out.println("LinkedList after add: " + ll);
        System.out.println("First: " + ll.getFirst() + ", Last: " + ll.getLast());

*******************************************************************************
System.out.println("\n--- Vector ---");
        Vector<String> vector = new Vector<>();
        vector.add("A"); vector.add("B");
        vector.addElement("C");              // Legacy method
        vector.remove(1);
        System.out.println("Vector: " + vector);
        System.out.println("Element at 0: " + vector.elementAt(0)); // legacy method
        vector.set(0, "Z");
        System.out.println("Modified Vector: " + vector);
        System.out.println("Capacity: " + vector.capacity());

*******************************************************************************
System.out.println("\n--- Stack ---");
        Stack<Integer> stack = new Stack<>();
        stack.push(100); stack.push(200);
        System.out.println("Top: " + stack.peek());
        stack.pop();
        System.out.println("After pop: " + stack);
        System.out.println("Is Empty? " + stack.isEmpty());
        System.out.println("Search(100): " + stack.search(100)); // 1-based index


*******************************************************************************
Common methods

list.addAll
list.retainAll
list.removeAll
Collections.reverse
Collections.sort
Collections.rotate(list,-2);
Collections.rotate(list,3);
Collections.reverse(list);
Collections.swap(list, 0, 2);
Collections.shuffle(list);
Collections.fill(list, "X");
int freq = Collections.frequency(list, "A");
Collections.max(list);
Collections.min(list);
List<String> original = new ArrayList<>(Arrays.asList("One", "Two"));
List<String> unmodifiable = Collections.unmodifiableList(original);

*******************************************************************************
LIST--->ARRAY
List<String> list = Arrays.asList("x", "y", "z");
        String[] arr = list.toArray(new String[0]);
        System.out.println(Arrays.toString(arr)); 

 List<String> list = new ArrayList<>();
        list.add("x");
        list.add("y");
        list.add("z");
        String[] arr = list.toArray(new String[0]);
        System.out.println(Arrays.toString(arr));

ARRAY-->LIST

int[] arr = {1, 2, 3};
List<Integer> list = new ArrayList<>();
for (int num : arr) list.add(num);
***************************************************************
List<String> list = List.of("Apple", "Banana", "Cherry");//IMMUTABLE


Prefer ArrayList for frequent reads and random access.

Use LinkedList for frequent insertions/removals at ends.

Avoid Vector unless thread-safety is needed (old, synchronized).

Stack is LIFO, internally uses Vector

************Programs*************
Array Operation	        Manual Implementation	            Built-in Method
Append	                arr[size++] = value;	          ArrayList.add(value);
Insert	                Shift elements, then insert	    ArrayList.add(index, value);
Delete	                Shift elements left	            ArrayList.remove(index);
Get	                    arr[index]	                    ArrayList.get(index);
Update                    arr[index] = value;	            ArrayList.set(index, value);
Search	                Loop through array	            ArrayList.indexOf(value);
Shift Left	            Loop and shift	                System.arraycopy()
Shift Right            	Loop and shift	                Collections.rotate(arr, -1);
Rotate Left	            Loop and swap	                  Collections.rotate(arr, -1);
Rotate Right	          Loop and swap                  	Collections.rotate(arr, 1);

**********************************************************************************************
Set is a part of Java Collections Framework.

It does not allow duplicate elements.

Elements are unordered (unless you use specific types like LinkedHashSet or TreeSet).

Belongs to java.util package.


Set<Integer> set1 = new HashSet<>();
Set<String> set2 = new LinkedHashSet<>();
Set<Double> set3 = new TreeSet<>();


Set<Integer> a = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> b = new HashSet<>(Arrays.asList(3, 4, 5));

// Union
Set<Integer> union = new HashSet<>(a);
union.addAll(b);  // [1, 2, 3, 4, 5]

// Intersection
Set<Integer> intersection = new HashSet<>(a);
intersection.retainAll(b);  // [3]

// Difference
Set<Integer> diff = new HashSet<>(a);
diff.removeAll(b);  // [1, 2]


| Method               | Description                               |
| -------------------- | ----------------------------------------- |
| `add(E e)`           | Adds an element if not already present    |
| `addAll(Collection)` | Adds all elements from another collection |
| `remove(Object o)`   | Removes the element                       |
| `contains(Object o)` | Checks if element exists                  |
| `isEmpty()`          | Checks if set is empty                    |
| `size()`             | Returns number of elements                |
| `clear()`            | Removes all elements                      |
| `iterator()`         | Returns an iterator                       |


1.Segregating positive and negative numbers

Using Arraylist
import java.util.*;

public class Main {
    public static void segregateArray(int[] arr) {
        List<Integer> positive = new ArrayList<>();
        List<Integer> negative = new ArrayList<>();

        for (int num : arr) {
            if (num >= 0)
                positive.add(num);
            else
                negative.add(num);
        }

        // Merge both lists back to array
        int i = 0;
        for (int num : negative) arr[i++] = num;
        for (int num : positive) arr[i++] = num;
    }

    public static void main(String[] args) {
        int[] arr = {12, -7, 5, -3, 9, -6, 8, -2};
        segregateArray(arr);
       System.out.println("Segregated Array: " + Arrays.toString(arr));
    
    }
}


Using pointers
import java.util.Arrays;

public class SegregateNumbers {
    public static void segregate(int[] arr) {
        int left = 0, right = arr.length - 1;

        while (left < right) {
            // Move left if it is negative
            if (arr[left] < 0) {
                left++;
            }
            // Move right if it is positive
            else if (arr[right] > 0) {
                right--;
            }
            // Swap when left is positive and right is negative
            else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {10, -1, 20, 4, -6, -9, 8, -3};
        System.out.println("Before segregation: " + Arrays.toString(arr));
        segregate(arr);
        System.out.println("After segregation: " + Arrays.toString(arr));
    }
}

2.Inserting in a sorted Array and checking if an Array is sorted

3.Merging two sorted arrays

4.Finding duplicate elements in a Integer array

5.Finding missing elements in Arrays - Different Methods

